"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalyticsClient = void 0;
const clientEvent_1 = require("./clientEvent");
const payloadTypes_1 = require("./payloadTypes");
const socket_1 = require("./socket");
const backoff_1 = require("./utils/backoff");
const event_1 = require("./utils/event");
const ANALYTICS_LOGGING_SERVER_DOMAIN = 'analytics-logging.skyway.ntt.com';
const API_VERSION = 'v1';
const TIMEOUT_SEC = 5;
class AnalyticsClient {
    constructor({ token, channelId, channelName, memberId, memberName, sdkVersion }, options) {
        this.onConnectionStateChanged = new event_1.Event();
        this.onConnectionFailed = new event_1.Event();
        this._isClosed = false;
        this._responseCallbacks = new Map();
        this._acknowledgeCallbacks = new Map();
        this._mediaDeviceVersion = new Map();
        this._encodingsVersion = new Map();
        this._preferredEncodingVersion = new Map();
        this._previousSubscriptionStats = new Map();
        this._statsRequest = {
            // connect()時のopenServerEventPayload.statsRequest代入でそれぞれ値が入るが，一度初期値として定義しておく
            intervalSec: 5,
            types: [],
        };
        this._token = token;
        this._newToken = undefined;
        this._channelId = channelId;
        this._channelName = channelName;
        this._memberId = memberId;
        this._memberName = memberName;
        this._sdkVersion = sdkVersion;
        const defaultOptions = {
            analyticsLoggingServerDomain: ANALYTICS_LOGGING_SERVER_DOMAIN,
            secure: true,
            logger: {
                debug: (message, ...optionalParams) => {
                    console.debug(message, ...optionalParams);
                },
                warn: (message, ...optionalParams) => {
                    console.warn(message, ...optionalParams);
                },
                error: (error) => {
                    console.error(error);
                },
            },
        };
        this._options = Object.assign({}, defaultOptions, options !== null && options !== void 0 ? options : {});
        this._logger = this._options.logger;
        this._logger.debug(`Created instance with the options: ${this._options}`);
    }
    get connectionState() {
        var _a, _b;
        return (_b = (_a = this._socket) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : 'closed';
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            const WSProtocol = this._options.secure ? 'wss' : 'ws';
            const analyticsLoggingServerDomain = this._options.analyticsLoggingServerDomain || ANALYTICS_LOGGING_SERVER_DOMAIN;
            this._socket = new socket_1.Socket({
                sessionEndpoint: `${WSProtocol}://${analyticsLoggingServerDomain}/${API_VERSION}/client/ws`,
                channelId: this._channelId,
                channelName: this._channelName,
                memberId: this._memberId,
                memberName: this._memberName,
                token: this._token,
                logger: this._logger,
                sdkVersion: this._sdkVersion,
            });
            this._socket.onEventReceived.addListener((data) => {
                try {
                    this._eventReceivedHandler(data);
                }
                catch (error) {
                    this._logger.error('in _eventReceivedHandler', error);
                }
            });
            this._socket.onConnectionFailed.addListener(() => {
                this.onConnectionFailed.emit();
                this._cleanupAnalyticsClientMaps();
            });
            this._socket.onConnectionStateChanged.addListener((state) => {
                var _a;
                if (state === 'closed' && !this.isClosed() && ((_a = this._socket) === null || _a === void 0 ? void 0 : _a.isClosed())) {
                    this._isClosed = true;
                    this.dispose();
                }
                this.onConnectionStateChanged.emit(state);
            });
            this._socket.onTokenExpired.addListener(() => {
                void this._reconnectWithNewSkyWayAuthToken();
            });
            const openServerEventPayload = yield this._socket.onOpened.asPromise();
            if (openServerEventPayload !== undefined) {
                this._statsRequest = openServerEventPayload.statsRequest;
                return;
            }
            else {
                this._logger.error('First time connection payload is undefined', new Error());
                this.onConnectionFailed.emit();
                return;
            }
        });
    }
    dispose() {
        this._disconnect();
        this._cleanupAnalyticsClientMaps();
    }
    setNewSkyWayAuthToken(token) {
        if (this._socket !== undefined) {
            this._newToken = token;
            this._logger.debug('setNewSkyWayAuthToken is success');
        }
    }
    cleanupOnUnpublished(publicationId) {
        this._mediaDeviceVersion.delete(publicationId);
        this._encodingsVersion.delete(publicationId);
    }
    cleanupOnUnsubscribed(subscriptionId) {
        this._preferredEncodingVersion.delete(subscriptionId);
        this._previousSubscriptionStats.delete(subscriptionId);
    }
    _disconnect() {
        var _a;
        (_a = this._socket) === null || _a === void 0 ? void 0 : _a.destroy();
        this._socket = undefined;
        this._responseCallbacks.clear();
        this._acknowledgeCallbacks.clear();
    }
    sendMediaDeviceReport(report) {
        return __awaiter(this, void 0, void 0, function* () {
            let currentMediaDeviceVersion = this._mediaDeviceVersion.get(report.publicationId);
            if (currentMediaDeviceVersion === undefined) {
                currentMediaDeviceVersion = 0;
            }
            else {
                currentMediaDeviceVersion++;
            }
            this._mediaDeviceVersion.set(report.publicationId, currentMediaDeviceVersion);
            const payload = {
                publicationId: report.publicationId,
                mediaDeviceName: report.mediaDeviceName,
                mediaDeviceVersion: currentMediaDeviceVersion,
                mediaDeviceTrigger: report.mediaDeviceTrigger,
                updatedAt: report.updatedAt,
            };
            const clientEvent = new clientEvent_1.ClientEvent('MediaDeviceReport', payload);
            yield this._sendClientEvent(clientEvent).catch((err) => {
                this._logger.warn('_sendClientEvent in sendMediaDeviceReport is failed', err);
            });
        });
    }
    sendBindingRtcPeerConnectionToSubscription(bindingData) {
        return __awaiter(this, void 0, void 0, function* () {
            const clientEvent = new clientEvent_1.ClientEvent('BindingRtcPeerConnectionToSubscription', bindingData);
            yield this._sendClientEvent(clientEvent).catch((err) => {
                this._logger.warn('_sendClientEvent in sendBindingRtcPeerConnectionToSubscription is failed', err);
            });
        });
    }
    _isDataChannelStatsReport(report) {
        const castedStatsReport = {};
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore RTCStatsReportの型エラー回避(TS2339: Property 'values' does not exist on type 'RTCStatsReport'.)
        for (const rtcStatsReportValue of report.values()) {
            castedStatsReport[rtcStatsReportValue.type] = rtcStatsReportValue;
        }
        if (castedStatsReport && 'data-channel' in castedStatsReport) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * DataChannelのstatsReportのobjectを処理する際の判定用関数
     * 'data-channel', 'local-candidate', 'candidate-pair' が現在対象
     * 'candidate-pair' の場合は nominated:true のもののみをtrueとする
     */
    _isTargetTypeOfStatsReport(report, targetType) {
        if (!report)
            return false;
        for (const type of targetType) {
            if (report.type === type) {
                if (type === 'data-channel' || type === 'local-candidate') {
                    return true;
                }
                else if (type === 'candidate-pair') {
                    // 'candidate-pair' の場合は nominated:true のものであるかを確認
                    if ('nominated' in report && report.nominated === true) {
                        return true;
                    }
                }
            }
        }
        // すべてのtypeに一致しない場合や条件に当てはまらない場合はfalse
        return false;
    }
    sendSubscriptionStatsReport(report, subscriptionParams) {
        return __awaiter(this, void 0, void 0, function* () {
            const previousSubscriptionStat = this._previousSubscriptionStats.get(subscriptionParams.subscriptionId);
            this._previousSubscriptionStats.set(subscriptionParams.subscriptionId, {
                stats: report,
                createdAt: subscriptionParams.createdAt,
            });
            if (previousSubscriptionStat === undefined) {
                // 初回の場合は時間あたりの値が出せないので送信しない
                return;
            }
            const previousCreatedAt = previousSubscriptionStat.createdAt;
            const duration = (subscriptionParams.createdAt - previousCreatedAt) / 1000; // mills to sec.
            if (duration <= 0) {
                throw new Error('duration must be greater than 0. also sendSubscriptionStatsReport was duplicated.');
            }
            const isDataChannelStatsReport = this._isDataChannelStatsReport(report);
            const filteredStats = {};
            for (const statsRequestType of this._statsRequest.types) {
                Object.keys(statsRequestType.properties).forEach((key) => {
                    const isNeedNormalization = statsRequestType.properties[key].normalization;
                    const outputKey = statsRequestType.properties[key].outputKey;
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore RTCStatsReportの型エラー回避(TS2339: Property 'values' does not exist on type 'RTCStatsReport'.)
                    for (const rtcStatsReportValue of report.values()) {
                        if (rtcStatsReportValue.type !== statsRequestType.type)
                            continue;
                        Object.keys(rtcStatsReportValue).forEach((statName) => {
                            if (statName === key) {
                                // 時折プロパティがない場合があるため，今回分のデータをチェックしておく
                                if (!rtcStatsReportValue || !(statName in rtcStatsReportValue)) {
                                    this._logger.warn(`statsReport key:${statName} in current statsReport is undefined`);
                                    return;
                                }
                                if (isNeedNormalization) {
                                    // 前回分のデータを使って時間あたりの値を計算する必要があるフィールドについてはこちらで処理
                                    /**
                                     * idは接続が続いている間同じ値を取るので,前回保持したstatsから値を取り出す際に利用する
                                     * https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport#common_instance_properties
                                     */
                                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                                    // @ts-ignore RTCStatsReportの型エラー回避(TS2339: Property 'get' does not exist on type 'RTCStatsReport')
                                    const previousObject = previousSubscriptionStat.stats.get(rtcStatsReportValue.id);
                                    // 時折プロパティがない場合があるため，前回分のデータをチェックしておく
                                    if (!previousObject || !(key in previousObject)) {
                                        this._logger.warn(`statsReport key:${key} in previous statsReport is undefined`);
                                        return;
                                    }
                                    const previousValue = Number(previousObject[key]);
                                    const perSecondValue = (Number(rtcStatsReportValue[statName]) - previousValue) / duration;
                                    if (isDataChannelStatsReport) {
                                        // 'data-channel'の場合はbytesSent/bytesReceivedの両方とも格納されてしまうのでroleによって切り替える
                                        if (this._isTargetTypeOfStatsReport(rtcStatsReportValue, ['data-channel'])) {
                                            if (subscriptionParams.role === 'sender') {
                                                if (statName === 'bytesSent') {
                                                    filteredStats[statsRequestType.type] = Object.assign(Object.assign({}, filteredStats[statsRequestType.type]), { [outputKey]: String(perSecondValue) });
                                                }
                                            }
                                            else {
                                                if (statName === 'bytesReceived') {
                                                    filteredStats[statsRequestType.type] = Object.assign(Object.assign({}, filteredStats[statsRequestType.type]), { [outputKey]: String(perSecondValue) });
                                                }
                                            }
                                        }
                                        else if (this._isTargetTypeOfStatsReport(rtcStatsReportValue, ['local-candidate', 'candidate-pair'])) {
                                            filteredStats[statsRequestType.type] = Object.assign(Object.assign({}, filteredStats[statsRequestType.type]), { [outputKey]: String(perSecondValue) });
                                        }
                                    }
                                    else {
                                        /**
                                         * this._statsRequest で保持している変換用のobjectは同一のkeyが複数回出てくるので，上書きしないためにスプレッド構文を利用する．
                                         * またServer側で受け付けているstatsの値はstringなので変換してやる必要あり．
                                         */
                                        filteredStats[statsRequestType.type] = Object.assign(Object.assign({}, filteredStats[statsRequestType.type]), { [outputKey]: String(perSecondValue) });
                                    }
                                }
                                else {
                                    // 時間あたりの値を計算する必要がないフィールドはこちらで処理
                                    if (isDataChannelStatsReport) {
                                        if (this._isTargetTypeOfStatsReport(rtcStatsReportValue, [
                                            'data-channel',
                                            'local-candidate',
                                            'candidate-pair',
                                        ])) {
                                            if (rtcStatsReportValue.type === 'candidate-pair') {
                                                // 'candidate-pair'はvideo/audioがある場合，他のフィールド:availableOutgoingBitrateも入ってきてしまうため必要なものに限定する
                                                if (statName === 'currentRoundTripTime') {
                                                    filteredStats[statsRequestType.type] = Object.assign(Object.assign({}, filteredStats[statsRequestType.type]), { [outputKey]: String(rtcStatsReportValue[statName]) });
                                                }
                                            }
                                            else {
                                                filteredStats[statsRequestType.type] = Object.assign(Object.assign({}, filteredStats[statsRequestType.type]), { [outputKey]: String(rtcStatsReportValue[statName]) });
                                            }
                                        }
                                    }
                                    else {
                                        filteredStats[statsRequestType.type] = Object.assign(Object.assign({}, filteredStats[statsRequestType.type]), { [outputKey]: String(rtcStatsReportValue[statName]) });
                                    }
                                }
                            }
                        });
                    }
                });
            }
            const payload = {
                subscriptionId: subscriptionParams.subscriptionId,
                stats: filteredStats,
                role: subscriptionParams.role,
                createdAt: subscriptionParams.createdAt,
            };
            const clientEvent = new clientEvent_1.ClientEvent('SubscriptionStatsReport', payload);
            yield this._sendClientEvent(clientEvent).catch((err) => {
                this._logger.warn('_sendClientEvent in sendSubscriptionStatsReport is failed', err);
            });
        });
    }
    sendRtcPeerConnectionEventReport(report) {
        return __awaiter(this, void 0, void 0, function* () {
            const clientEvent = new clientEvent_1.ClientEvent('RtcPeerConnectionEventReport', report);
            yield this._sendClientEvent(clientEvent).catch((err) => {
                this._logger.warn('_sendClientEvent in sendRtcPeerConnectionEventReport is failed', err);
            });
        });
    }
    sendPublicationUpdateEncodingsReport(report) {
        return __awaiter(this, void 0, void 0, function* () {
            let currentEncodingsVersion = this._encodingsVersion.get(report.publicationId);
            if (currentEncodingsVersion === undefined) {
                currentEncodingsVersion = 0;
            }
            else {
                currentEncodingsVersion++;
            }
            this._encodingsVersion.set(report.publicationId, currentEncodingsVersion);
            const payload = {
                publicationId: report.publicationId,
                encodings: report.encodings,
                encodingsVersion: currentEncodingsVersion,
                updatedAt: report.updatedAt,
            };
            const clientEvent = new clientEvent_1.ClientEvent('PublicationUpdateEncodingsReport', payload);
            yield this._sendClientEvent(clientEvent).catch((err) => {
                this._logger.warn('_sendClientEvent in sendPublicationUpdateEncodingsReport is failed', err);
            });
        });
    }
    sendSubscriptionUpdatePreferredEncodingReport(report) {
        return __awaiter(this, void 0, void 0, function* () {
            let currentPreferredEncodingVersion = this._preferredEncodingVersion.get(report.subscriptionId);
            if (currentPreferredEncodingVersion === undefined) {
                currentPreferredEncodingVersion = 0;
            }
            else {
                currentPreferredEncodingVersion++;
            }
            this._preferredEncodingVersion.set(report.subscriptionId, currentPreferredEncodingVersion);
            const payload = {
                subscriptionId: report.subscriptionId,
                preferredEncodingIndex: report.preferredEncodingIndex,
                preferredEncodingVersion: currentPreferredEncodingVersion,
                updatedAt: report.updatedAt,
            };
            const clientEvent = new clientEvent_1.ClientEvent('SubscriptionUpdatePreferredEncodingReport', payload);
            yield this._sendClientEvent(clientEvent).catch((err) => {
                this._logger.warn('_sendClientEvent in sendSubscriptionUpdatePreferredEncodingReport is failed', err);
            });
        });
    }
    _sendClientEvent(clientEvent) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (this._socket === undefined || this._socket.connectionState === 'closed') {
                    reject(new Error('websocket is not connected'));
                    return;
                }
                // 初回の接続に時間がかかっている場合はここで再送用のキューとacknowledgeのリストに入れる
                if (this._socket.connectionState === 'connecting') {
                    this._socket.pushResendClientEventsQueue(clientEvent);
                    this._setAcknowledgeCallback(clientEvent.id, (data) => __awaiter(this, void 0, void 0, function* () {
                        if (data.ok) {
                            this._acknowledgeCallbacks.delete(clientEvent.id);
                            resolve();
                        }
                        else {
                            this._acknowledgeCallbacks.delete(clientEvent.id);
                            reject(data);
                        }
                    }));
                    this._logger.debug(`pushResendClientEventsQueue and setAcknowledgeCallback. clientEvent.id: ${clientEvent.id}`);
                    reject(new Error('websocket is connecting now'));
                    return;
                }
                const backoff = new backoff_1.BackOff({ times: 6, interval: 500, jitter: 100 });
                for (; !backoff.exceeded;) {
                    const timer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        if (this._socket === undefined) {
                            this._acknowledgeCallbacks.delete(clientEvent.id);
                            reject(new Error('Socket closed when trying to resend'));
                            return;
                        }
                        else {
                            this._socket.resendAfterReconnect(clientEvent);
                        }
                        reject(new Error('Timeout to send data'));
                        return;
                    }), TIMEOUT_SEC * 1000);
                    // 送信に失敗した際の再送ロジックはsend()内で処理される
                    this._logger.debug(`send clientEvent, ${JSON.stringify(clientEvent)}`);
                    this._socket.send(clientEvent).catch((err) => {
                        this._acknowledgeCallbacks.delete(clientEvent.id);
                        clearTimeout(timer);
                        reject(err);
                        return;
                    });
                    /**
                     * _waitForAcknowledgeはresultに次の2種類の値を返す
                     * 1. undefined: 送信が成功し、undefinedでresolveされた場合
                     * 2. AcknowledgePayload型の値:送信は成功したがサーバーから ok: false のacknowledgeが返されたため、acknowledge payloadでrejectされた場合
                     * 何らかのエラーによってrejectされた場合:
                     * これは_messageHandlerで弾かれるので考慮しなくて良い．
                     */
                    const result = yield this._waitForAcknowledge(clientEvent.id).catch((err) => {
                        return err;
                    });
                    clearTimeout(timer);
                    if ((0, payloadTypes_1.isAcknowledgePayload)(result)) {
                        if (result.reason === 'unexpected') {
                            yield backoff.wait();
                        }
                        else {
                            reject(result);
                            return;
                        }
                    }
                    else {
                        resolve();
                        return;
                    }
                }
                reject(new Error('unexpected has occurred at server'));
                return;
            }));
        });
    }
    _waitForAcknowledge(clientEventId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this._setAcknowledgeCallback(clientEventId, (data) => __awaiter(this, void 0, void 0, function* () {
                    if (data.ok) {
                        this._acknowledgeCallbacks.delete(clientEventId);
                        resolve();
                    }
                    else {
                        this._acknowledgeCallbacks.delete(clientEventId);
                        reject(data);
                    }
                }));
            });
        });
    }
    _reconnectWithNewSkyWayAuthToken() {
        return __awaiter(this, void 0, void 0, function* () {
            this._disconnect();
            if (this._newToken !== undefined) {
                this._token = this._newToken;
                this._newToken = undefined;
                yield this.connect();
            }
            else {
                this._logger.warn('new token is not set. so not reconnect.');
            }
        });
    }
    _eventReceivedHandler(data) {
        switch (data.type) {
            case 'Acknowledge':
                this._acknowledgeHandler(data.payload);
                break;
            case 'Open':
                break; // nop
            default: {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _ = data.type;
                this._logger.warn(`Unknown event: ${data.type}`);
            }
        }
    }
    _acknowledgeHandler(payload) {
        if (!(0, payloadTypes_1.isAcknowledgePayload)(payload)) {
            throw new Error('Invalid payload');
        }
        const { eventId } = payload;
        if (!this._acknowledgeCallbacks.has(eventId)) {
            throw new Error(`acknowledge event has unknown eventId: ${eventId}`);
        }
        const callback = this._acknowledgeCallbacks.get(eventId);
        if (callback) {
            this._acknowledgeCallbacks.delete(eventId);
            callback(payload);
        }
    }
    _setAcknowledgeCallback(eventId, callback) {
        this._acknowledgeCallbacks.set(eventId, callback);
    }
    _cleanupAnalyticsClientMaps() {
        this._mediaDeviceVersion.clear();
        this._encodingsVersion.clear();
        this._preferredEncodingVersion.clear();
        this._previousSubscriptionStats.clear();
    }
    getIntervalSec() {
        return this._statsRequest.intervalSec;
    }
    isConnectionEstablished() {
        if (!this._socket || this._socket.connectionState === 'connecting' || this._socket.connectionState === 'closed') {
            return false;
        }
        else {
            return true;
        }
    }
    isClosed() {
        return this._isClosed;
    }
}
exports.AnalyticsClient = AnalyticsClient;
//# sourceMappingURL=analyticsClient.js.map