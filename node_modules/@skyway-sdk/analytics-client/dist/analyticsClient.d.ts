import { BindingRtcPeerConnectionToSubscriptionClientEvent, MediaDeviceReportClientEvent, PublicationUpdateEncodingsReportClientEvent, RtcPeerConnectionEventReportClientEvent, SubscriptionStatsReportClientEvent, SubscriptionUpdatePreferredEncodingReportClientEvent } from './clientEvent';
import { ConnectionState } from './socket';
import { Event } from './utils/event';
import { Logger } from './utils/logger';
declare type AnalyticsClientParams = {
    token: string;
    channelId: string;
    channelName?: string;
    memberId: string;
    memberName?: string;
    sdkVersion: string;
};
declare type AnalyticsClientOptions = {
    analyticsLoggingServerDomain?: string;
    secure?: boolean;
    logger?: Logger;
};
declare type MediaDeviceReport = MediaDeviceReportClientEvent['payload'];
declare type BindingRtcPeerConnectionToSubscription = BindingRtcPeerConnectionToSubscriptionClientEvent['payload'];
declare type SubscriptionStatsReport = SubscriptionStatsReportClientEvent['payload'];
declare type RtcPeerConnectionEventReport = RtcPeerConnectionEventReportClientEvent['payload'];
declare type PublicationUpdateEncodingsReport = PublicationUpdateEncodingsReportClientEvent['payload'];
declare type SubscriptionUpdatePreferredEncodingReport = SubscriptionUpdatePreferredEncodingReportClientEvent['payload'];
export declare class AnalyticsClient {
    private readonly _options;
    private readonly _logger;
    private _socket;
    readonly onConnectionStateChanged: Event<ConnectionState>;
    readonly onConnectionFailed: Event<void>;
    private _token;
    private _newToken;
    private readonly _channelId;
    private readonly _channelName?;
    private readonly _memberId;
    private readonly _memberName?;
    private readonly _sdkVersion;
    private _isClosed;
    private _responseCallbacks;
    private _acknowledgeCallbacks;
    private _mediaDeviceVersion;
    private _encodingsVersion;
    private _preferredEncodingVersion;
    private _previousSubscriptionStats;
    private _statsRequest;
    constructor({ token, channelId, channelName, memberId, memberName, sdkVersion }: AnalyticsClientParams, options?: AnalyticsClientOptions);
    get connectionState(): ConnectionState;
    connect(): Promise<void>;
    dispose(): void;
    setNewSkyWayAuthToken(token: string): void;
    cleanupOnUnpublished(publicationId: string): void;
    cleanupOnUnsubscribed(subscriptionId: string): void;
    private _disconnect;
    sendMediaDeviceReport(report: Omit<MediaDeviceReport, 'mediaDeviceVersion'>): Promise<void>;
    sendBindingRtcPeerConnectionToSubscription(bindingData: BindingRtcPeerConnectionToSubscription): Promise<void>;
    private _isDataChannelStatsReport;
    /**
     * DataChannelのstatsReportのobjectを処理する際の判定用関数
     * 'data-channel', 'local-candidate', 'candidate-pair' が現在対象
     * 'candidate-pair' の場合は nominated:true のもののみをtrueとする
     */
    private _isTargetTypeOfStatsReport;
    sendSubscriptionStatsReport(report: RTCStatsReport, subscriptionParams: Omit<SubscriptionStatsReport, 'stats'>): Promise<void>;
    sendRtcPeerConnectionEventReport(report: RtcPeerConnectionEventReport): Promise<void>;
    sendPublicationUpdateEncodingsReport(report: Omit<PublicationUpdateEncodingsReport, 'encodingsVersion'>): Promise<void>;
    sendSubscriptionUpdatePreferredEncodingReport(report: Omit<SubscriptionUpdatePreferredEncodingReport, 'preferredEncodingVersion'>): Promise<void>;
    private _sendClientEvent;
    private _waitForAcknowledge;
    private _reconnectWithNewSkyWayAuthToken;
    private _eventReceivedHandler;
    private _acknowledgeHandler;
    private _setAcknowledgeCallback;
    private _cleanupAnalyticsClientMaps;
    getIntervalSec(): number;
    isConnectionEstablished(): boolean;
    isClosed(): boolean;
}
export {};
//# sourceMappingURL=analyticsClient.d.ts.map