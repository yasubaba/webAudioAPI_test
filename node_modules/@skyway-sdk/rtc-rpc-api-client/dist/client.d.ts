import { BackOff, LogFormat, LogLevel, SkyWayError } from '@skyway-sdk/common';
import model, { Channel, Codec, ContentType, Encoding, Member, Publication } from '@skyway-sdk/model';
import { ChannelEvent } from './event';
import { RPC } from './rpc';
/**@internal */
export interface RtcRpcApiConfig {
    domain?: string;
    /**ms */
    timeout?: number;
    secure?: boolean;
}
export declare type RtcRpcApiClientConfig = RtcRpcApiConfig & {
    token: string;
    log?: Partial<{
        level: LogLevel;
        format: LogFormat;
    }>;
};
export declare class RtcRpcApiClient {
    readonly config: RtcRpcApiClientConfig;
    closed: boolean;
    private readonly _domain;
    private _secure;
    private _token;
    /**@private */
    _rpc: RPC;
    private _subscribingChannelEvents;
    private _subscribingChannelVersions;
    private readonly _httpClient;
    private _reconnectCount;
    private readonly _reconnectLimit;
    private readonly _events;
    readonly onEvent: import("@skyway-sdk/common").Event<{
        channelId: string;
        event: ChannelEvent;
    }>;
    readonly onFatalError: import("@skyway-sdk/common").Event<SkyWayError<Record<string, any>>>;
    readonly onClose: import("@skyway-sdk/common").Event<void>;
    readonly onReconnected: import("@skyway-sdk/common").Event<void>;
    constructor(config: RtcRpcApiClientConfig);
    get token(): string;
    private _reconnect;
    updateToken(token: string): Promise<void>;
    close(): void;
    health(): Promise<unknown>;
    /** @throws {@link SkyWayError} */
    connect(): Promise<void>;
    private _channelSubscribed;
    private _isSubscribingChannel;
    createChannel({ name, metadata, appId, }: {
        name?: Channel['name'];
        metadata?: string;
        appId: string;
    }): Promise<{
        id: string;
        version: number;
    }>;
    findOrCreateChannel({ name, metadata, appId, }: {
        appId: string;
        name?: Channel['name'];
        metadata?: string;
    }): Promise<model.Channel>;
    getChannel({ appId, id }: {
        appId: string;
        id: Channel['id'];
    }): Promise<model.Channel>;
    getChannelByName({ name, appId, }: {
        appId: string;
        name: Channel['name'];
    }): Promise<model.Channel>;
    deleteChannel({ id, appId }: {
        appId: string;
        id: Channel['id'];
    }): Promise<void>;
    updateChannelMetadata({ id, metadata, appId, }: {
        id: Channel['id'];
        appId: string;
        metadata: string;
    }): Promise<void>;
    addMember({ channelId, name, metadata, subscribeChannelEvents, appId, ttlSec, subtype, type, }: {
        appId: string;
        channelId: Channel['id'];
        name?: Member['name'];
        metadata?: Member['metadata'];
        subscribeChannelEvents?: boolean;
        /**unixtimestamp in seconds */
        ttlSec?: number;
        type?: string;
        subtype?: string;
    }): Promise<object & {
        memberId: model.Member['id'];
        version: model.Channel['version'];
    }>;
    updateMemberTtl(args: {
        appId: string;
        channelId: string;
        memberId: string;
        /**unixtimestamp in seconds */
        ttlSec: number;
    }, backoff?: BackOff): Promise<void>;
    updateMemberMetadata({ channelId, memberId, metadata, appId, }: {
        appId: string;
        channelId: string;
        memberId: string;
        metadata: string;
    }): Promise<void>;
    leaveChannel({ channelId, id, appId, }: {
        appId: string;
        channelId: string;
        id: string;
    }): Promise<void>;
    publishStream({ appId, channelId, publisherId, contentType, metadata, origin, codecCapabilities, encodings, }: {
        appId: string;
        channelId: string;
        publisherId: string;
        contentType: ContentType;
        metadata?: string;
        origin?: string;
        codecCapabilities?: Codec[];
        encodings?: Encoding[];
    }): Promise<{
        publicationId: string;
    }>;
    disablePublication({ channelId, publicationId, appId, }: {
        appId: string;
        channelId: string;
        publicationId: string;
    }): Promise<void>;
    enablePublication({ channelId, publicationId, appId, }: {
        appId: string;
        channelId: string;
        publicationId: string;
    }): Promise<void>;
    updatePublicationMetadata({ channelId, publicationId, appId, metadata, }: {
        appId: string;
        channelId: string;
        publicationId: string;
        metadata: string;
    }): Promise<void>;
    unpublishStream({ channelId, publicationId, appId, }: {
        appId: string;
        channelId: string;
        publicationId: string;
    }): Promise<void>;
    subscribeStream({ channelId, subscriberId, publicationId, appId, }: {
        appId: string;
        channelId: Channel['id'];
        subscriberId: Member['id'];
        publicationId: Publication['id'];
    }): Promise<{
        subscriptionId: string;
    }>;
    unsubscribeStream({ channelId, subscriptionId, appId, }: {
        appId: string;
        channelId: string;
        subscriptionId: string;
    }): Promise<void>;
    /**
     * @returns Date.now()
     */
    getServerUnixtime(args: {
        appId: string;
    }, backoff?: BackOff): Promise<number>;
    /**@description [japanese] 現在のセッションに関連付けられている SkyWayAuthToken を更新します */
    private _updateAuthToken;
    /**
     * @description
     * - 指定した Channel の Event を Subscribe していなければ Event が生じるたびに Notification が送られるようになります。
     * - Subscribeした時点で、指定された offset (default to 0) の version から、最新の version までのイベントが送られます。
     */
    subscribeChannelEvents({ appId, channelId, offset, }: {
        appId: string;
        channelId: Channel['id'];
        offset?: number;
    }): Promise<void>;
}
//# sourceMappingURL=client.d.ts.map