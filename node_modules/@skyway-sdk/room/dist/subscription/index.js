"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoomSubscriptionImpl = void 0;
const common_1 = require("@skyway-sdk/common");
const core_1 = require("@skyway-sdk/core");
const errors_1 = require("../errors");
const util_1 = require("../util");
const log = new common_1.Logger('packages/room/src/subscription/index.ts');
/**@internal */
class RoomSubscriptionImpl {
    constructor(
    /**@private */
    _subscription, _room) {
        this._subscription = _subscription;
        this._room = _room;
        this._context = this._room._context;
        this.onStreamAttached = new core_1.Event();
        this.onCanceled = new core_1.Event();
        this.onConnectionStateChanged = new core_1.Event();
        this.id = _subscription.id;
        this.contentType = _subscription.contentType;
        this.publication = this._room._getPublication(_subscription.publication.id);
        this.subscriber = this._room._getMember(_subscription.subscriber.id);
        _subscription.onStreamAttached.pipe(this.onStreamAttached);
        _subscription.onCanceled.pipe(this.onCanceled);
        _subscription.onConnectionStateChanged.add((state) => {
            log.debug('_subscription.onConnectionStateChanged', this.id, state);
            this.onConnectionStateChanged.emit(state);
        });
    }
    get stream() {
        return this._subscription.stream;
    }
    get state() {
        return this._subscription.state;
    }
    get codec() {
        return this._subscription.codec;
    }
    get preferredEncoding() {
        return this._subscription.preferredEncoding;
    }
    changePreferredEncoding(id) {
        this._subscription.changePreferredEncoding(id);
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            this._subscription.cancel().catch((error) => {
                log.error('subscription.cancel', error, this.toJSON());
            });
            yield this._room.onPublicationUnsubscribed
                .watch((e) => e.subscription.id === this.id, this._context.config.rtcApi.timeout)
                .catch((error) => {
                throw (0, util_1.createError)({
                    operationName: 'RoomSubscriptionImpl.cancel',
                    context: this._context,
                    room: this._room,
                    info: Object.assign(Object.assign({}, errors_1.errors.timeout), { detail: 'onPublicationUnsubscribed' }),
                    error,
                    path: log.prefix,
                });
            });
        });
    }
    toJSON() {
        return {
            id: this.id,
            contentType: this.contentType,
            publication: this.publication,
            codec: this.codec,
        };
    }
    getStats() {
        return this._subscription.getStats();
    }
    getRTCPeerConnection() {
        return this._subscription.getRTCPeerConnection();
    }
    getConnectionState() {
        return this._subscription.getConnectionState();
    }
}
exports.RoomSubscriptionImpl = RoomSubscriptionImpl;
//# sourceMappingURL=index.js.map