"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IceManager = void 0;
const common_1 = require("@skyway-sdk/common");
const log = new common_1.Logger('packages/core/src/external/ice.ts');
/**@internal */
class IceManager {
    constructor(args) {
        this.args = args;
        this.domain = this.args.domain;
        this.version = this.args.version;
        this.secure = this.args.secure;
        this.memberId = this.args.memberId;
        this.channelId = this.args.channelId;
        this.ttl = this.args.ttl;
        this.context = this.args.context;
        this._stunServers = [];
        this._turnServers = [];
        this._endpoint = `http${this.secure ? 's' : ''}://${this.domain}/v${this.version}`;
        this.http = new common_1.HttpClient(this._endpoint);
    }
    updateIceParams() {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                memberId: this.memberId,
                channelId: this.channelId,
                ttl: this.ttl,
            };
            log.debug('[start] fetch iceParams');
            const backoff = new common_1.BackOff({ times: 6, interval: 500, jitter: 100 });
            const { turn, stun } = yield this.http.post(`/ice-params`, body, {
                headers: { authorization: `Bearer ${this.context.authTokenString}` },
                retry: () => backoff.wait(),
            });
            if (turn) {
                this._turnServers = [
                    {
                        credential: turn.credential,
                        urls: `turn:${turn.domain}:${turn.port}?transport=tcp`,
                        username: turn.username,
                    },
                    {
                        credential: turn.credential,
                        urls: `turn:${turn.domain}:${turn.port}?transport=udp`,
                        username: turn.username,
                    },
                    {
                        credential: turn.credential,
                        urls: `turns:${turn.domain}:${turn.port}?transport=tcp`,
                        username: turn.username,
                    },
                ];
            }
            this._stunServers = [{ urls: `stun:${stun.domain}:${stun.port}` }];
            log.debug('[end] fetch iceParams', { turn, stun });
        });
    }
    get iceServers() {
        let iceServers = [...this._stunServers];
        const turnServers = this._turnServers.filter((t) => {
            const url = t.urls;
            switch (this.context.config.rtcConfig.turnProtocol) {
                case 'all':
                    return true;
                case 'udp':
                    return url.endsWith('udp');
                case 'tcp':
                    return !url.startsWith('turns') && url.endsWith('tcp');
                case 'tls':
                    return url.startsWith('turns');
            }
        });
        if (this.context.config.rtcConfig.turnPolicy !== 'disable') {
            iceServers = [...iceServers, ...turnServers];
        }
        return iceServers;
    }
}
exports.IceManager = IceManager;
//# sourceMappingURL=ice.js.map