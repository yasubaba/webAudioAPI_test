"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionImpl = void 0;
const common_1 = require("@skyway-sdk/common");
const common_2 = require("@skyway-sdk/common");
const errors_1 = require("../errors");
const util_1 = require("../util");
__exportStar(require("./factory"), exports);
const log = new common_1.Logger('packages/core/src/subscription/index.ts');
/**@internal */
class SubscriptionImpl {
    constructor(args) {
        this._disposer = new common_1.EventDisposer();
        this._state = 'enabled';
        this.onCanceled = new common_2.Event();
        this.onStreamAttached = new common_2.Event();
        this.onConnectionStateChanged = new common_2.Event();
        /**@internal */
        this._onChangeEncoding = new common_2.Event();
        this.cancel = () => new Promise((r, f) => {
            let failed = false;
            this._channel._unsubscribe(this.id).catch((e) => {
                failed = true;
                f(e);
            });
            this.onCanceled
                .asPromise(this._context.config.rtcApi.timeout)
                .then(() => r())
                .catch((e) => {
                if (!failed)
                    f(e);
            });
        });
        this._channel = args.channel;
        this._context = this._channel._context;
        this.id = args.id;
        this.contentType = args.contentType;
        this.subscriber = args.subscriber;
        this.publication = args.publication;
        log.debug('subscription spawned', this.toJSON());
        this._handlePublicationEnabled();
    }
    get state() {
        return this._state;
    }
    _handlePublicationEnabled() {
        this.publication.onDisabled
            .add(() => {
            if (this.stream) {
                log.debug('disabled', this);
                this.stream.setIsEnabled(false);
            }
        })
            .disposer(this._disposer);
        this.publication.onEnabled
            .add(() => {
            if (this.stream) {
                log.debug('enabled', this);
                this.stream.setIsEnabled(true);
            }
        })
            .disposer(this._disposer);
        if (this.stream) {
            this.stream.setIsEnabled(this.publication.state === 'enabled');
        }
    }
    /**@internal */
    _setStream(stream) {
        this._stream = stream;
        this.onStreamAttached.emit();
        stream._onConnectionStateChanged.add((e) => {
            log.debug('onConnectionStateChanged', this.id, e);
            this.onConnectionStateChanged.emit(e);
        });
    }
    get stream() {
        return this._stream;
    }
    toJSON() {
        return {
            id: this.id,
            contentType: this.contentType,
            subscriber: this.subscriber,
            publication: this.publication,
            channelId: this._channel.id,
            state: this.state,
            stream: this.stream,
        };
    }
    /**@private */
    _canceled() {
        this._state = 'canceled';
        this.onCanceled.emit();
        this._disposer.dispose();
    }
    changePreferredEncoding(id) {
        if (!this.stream) {
            throw (0, util_1.createError)({
                operationName: 'SubscriptionImpl.changePreferredEncoding',
                info: errors_1.errors.streamNotExistInSubscription,
                path: log.prefix,
                context: this._context,
                channel: this._channel,
            });
        }
        if (this.stream.contentType === 'data') {
            throw (0, util_1.createError)({
                operationName: 'SubscriptionImpl.changePreferredEncoding',
                info: errors_1.errors.dataStreamNotSupportEncoding,
                path: log.prefix,
                context: this._context,
                channel: this._channel,
            });
        }
        if (!this.publication.encodings.map((e) => e.id).includes(id)) {
            throw (0, util_1.createError)({
                operationName: 'SubscriptionImpl.changePreferredEncoding',
                info: errors_1.errors.correspondingEncodeNotExistForId,
                path: log.prefix,
                context: this._context,
                channel: this._channel,
            });
        }
        this.preferredEncoding = id;
        this._onChangeEncoding.emit();
    }
    getStats() {
        if (!this.stream) {
            throw (0, util_1.createError)({
                operationName: 'SubscriptionImpl.getStats',
                info: errors_1.errors.streamNotExistInSubscription,
                path: log.prefix,
                context: this._context,
                channel: this._channel,
            });
        }
        return this.stream._getStats();
    }
    getRTCPeerConnection() {
        if (!this.stream) {
            throw (0, util_1.createError)({
                operationName: 'SubscriptionImpl.getRTCPeerConnection',
                info: errors_1.errors.streamNotExistInSubscription,
                path: log.prefix,
                context: this._context,
                channel: this._channel,
            });
        }
        return this.stream._getRTCPeerConnection();
    }
    getConnectionState() {
        if (!this.stream) {
            throw (0, util_1.createError)({
                operationName: 'SubscriptionImpl.getConnectionState',
                info: errors_1.errors.streamNotExistInSubscription,
                path: log.prefix,
                context: this._context,
                channel: this._channel,
            });
        }
        return this.stream._getConnectionState();
    }
}
exports.SubscriptionImpl = SubscriptionImpl;
//# sourceMappingURL=index.js.map