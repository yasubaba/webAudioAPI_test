"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.statsToJson = exports.convertConnectionState = exports.isSafari = exports.setEncodingParams = void 0;
const common_1 = require("@skyway-sdk/common");
const util_1 = require("../../../util");
const log = new common_1.Logger('packages/core/src/plugin/internal/person/util.ts');
/**@internal */
const setEncodingParams = (sender, newEncodings) => __awaiter(void 0, void 0, void 0, function* () {
    const info = log.createBlock({ label: 'setEncodingParams' });
    const params = sender.getParameters();
    info.debug('getParameters', { params, newEncodings });
    if (params.encodings == undefined) {
        params.encodings = [];
    }
    params.encodings = newEncodings.map((encoding, i) => (Object.assign(Object.assign({}, (params.encodings[i] || {})), encoding)));
    yield sender.setParameters(params);
});
exports.setEncodingParams = setEncodingParams;
/**@internal */
const isSafari = () => (0, util_1.detectDevice)() === 'Safari12' || (0, util_1.detectDevice)() === 'Safari11';
exports.isSafari = isSafari;
/**@internal */
function convertConnectionState(state) {
    switch (state) {
        case 'closed':
        case 'disconnected':
        case 'failed':
            return 'disconnected';
        case 'connected':
            return 'connected';
        case 'connecting':
            return 'connecting';
        case 'new':
            return 'new';
        case 'reconnecting':
            return 'reconnecting';
    }
}
exports.convertConnectionState = convertConnectionState;
/**@internal */
const statsToJson = (report) => {
    const stats = [];
    report.forEach((stat) => {
        stats.push(JSON.parse(JSON.stringify(stat)));
    });
    return stats;
};
exports.statsToJson = statsToJson;
//# sourceMappingURL=util.js.map