import { Event } from '@skyway-sdk/common';
import { SkyWayContext } from '../../../../context';
import { AnalyticsSession } from '../../../../external/analytics';
import { IceManager } from '../../../../external/ice';
import { SignalingSession } from '../../../../external/signaling';
import { LocalPersonImpl } from '../../../../member/localPerson';
import { RemoteMember } from '../../../../member/remoteMember';
import { P2PMessage } from '.';
export declare abstract class Peer {
    protected readonly _context: SkyWayContext;
    protected readonly _iceManager: IceManager;
    protected readonly signaling: SignalingSession;
    protected readonly analytics: AnalyticsSession | undefined;
    protected readonly localPerson: LocalPersonImpl;
    protected readonly endpoint: RemoteMember;
    readonly role: PeerRole;
    private _pendingCandidates;
    readonly pc: RTCPeerConnection;
    readonly onSignalingStateChanged: Event<RTCSignalingState>;
    readonly onPeerConnectionStateChanged: Event<RTCPeerConnectionState>;
    readonly onDisconnect: Event<void>;
    connected: boolean;
    disconnected: boolean;
    rtcPeerConnectionId: string;
    constructor(_context: SkyWayContext, _iceManager: IceManager, signaling: SignalingSession, analytics: AnalyticsSession | undefined, localPerson: LocalPersonImpl, endpoint: RemoteMember, role: PeerRole);
    private setPeerConnectionListener;
    protected unSetPeerConnectionListener(): void;
    private _onICECandidate;
    private _onICECandidateError;
    private _onIceGatheringStateChange;
    private _onConnectionStateChange;
    private _onIceConnectionStateChange;
    private _onSignalingStateChange;
    handleCandidate(candidate: RTCIceCandidate): Promise<void>;
    resolveCandidates(): Promise<void>;
    /**@throws {@link SkyWayError} */
    protected waitForSignalingState: (state: RTCSignalingState, timeout?: number) => Promise<void>;
    /**@throws {@link SkyWayError} */
    protected waitForConnectionState: (state: RTCPeerConnectionState, timeout?: number) => Promise<void>;
    /**@throws {@link SkyWayError} */
    protected waitForStats: ({ track, cb, interval, timeout, logging, }: {
        track: MediaStreamTrack;
        cb: (stats: {
            [key: string]: any;
            id: string;
            type: string;
        }[]) => boolean;
        /**ms */
        interval?: number | undefined;
        /**ms */
        timeout?: number | undefined;
        logging?: boolean | undefined;
    }) => Promise<void>;
}
export declare type PeerRole = 'sender' | 'receiver';
export interface IceCandidateMessage extends P2PMessage {
    kind: 'iceCandidateMessage';
    payload: {
        candidate: RTCIceCandidate;
        role: 'receiver' | 'sender';
    };
}
//# sourceMappingURL=peer.d.ts.map