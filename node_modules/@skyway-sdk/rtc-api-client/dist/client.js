"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RtcApiClient = void 0;
const common_1 = require("@skyway-sdk/common");
const common_2 = require("@skyway-sdk/common");
const rtc_rpc_api_client_1 = require("@skyway-sdk/rtc-rpc-api-client");
const _1 = require(".");
const config_1 = require("./config");
const api_1 = require("./infrastructure/api");
const eventObserver_1 = require("./infrastructure/eventObserver");
const log = new common_1.Logger('packages/rtc-api-client/src/client.ts');
class RtcApiClient {
    constructor(appId, config, apiClient, _eventObserverFactory) {
        this.appId = appId;
        this.config = config;
        this.apiClient = apiClient;
        this._eventObserverFactory = _eventObserverFactory;
        this.closed = false;
        this.onFatalError = new common_2.Event();
        this.apiClient.onFatalError.pipe(this.onFatalError);
    }
    /** @throws {@link SkyWayError} */
    static Create(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = new config_1.Config(args);
            if (config.log) {
                common_1.Logger.level = config.log.level;
                common_1.Logger.format = config.log.format;
            }
            log.debug('RtcApiClient spawned', config);
            const rpc = new rtc_rpc_api_client_1.RtcRpcApiClient(Object.assign(Object.assign({}, config.rtcApi), { token: args.token, log: config.log }));
            const api = new api_1.RtcApiImpl(rpc);
            yield api.connect();
            const eventObserverFactory = (appId, channel) => new eventObserver_1.EventObserverImpl(appId, rpc, channel, config.rtcApi);
            return new RtcApiClient(args.appId, config, api, eventObserverFactory);
        });
    }
    updateAuthToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.apiClient.updateAuthToken(token);
        });
    }
    /**ms */
    getServerUnixtimeInMs() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiClient.getServerUnixtime(this.appId);
        });
    }
    /**sec */
    getServerUnixtimeInSec() {
        return __awaiter(this, void 0, void 0, function* () {
            return Math.floor((yield this.getServerUnixtimeInMs()) / 1000);
        });
    }
    /**@throws {@link SkyWayError} */
    createChannel(init = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug('[start] apiClient.createChannel', { init });
            const channelDto = yield this.apiClient
                .createChannel(this.appId, init)
                .catch((e) => {
                log.debug('[failed] apiClient.createChannel', { init, e });
                throw e;
            });
            log.debug('[end] apiClient.createChannel', { init, channelDto });
            const channel = (0, _1.channelFactory)(this.appId, this._eventObserverFactory(this.appId, channelDto), this.apiClient, channelDto, this.config);
            return channel;
        });
    }
    findChannel(query) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug('[start] apiClient.getChannel', { query });
            const channelDto = yield this.apiClient
                .getChannel(this.appId, query)
                .catch((e) => {
                log.debug('[failed] apiClient.getChannel', { query, e });
                throw e;
            });
            const channel = (0, _1.channelFactory)(this.appId, this._eventObserverFactory(this.appId, channelDto), this.apiClient, channelDto, this.config);
            log.debug('[end] apiClient.getChannel', { channelId: channel.id });
            return channel;
        });
    }
    findOrCreateChannel(query) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug('[start] apiClient.findOrCreateChannel', { query });
            const channelDto = yield this.apiClient
                .findOrCreateChannel(this.appId, query)
                .catch((e) => {
                log.debug('[failed] apiClient.findOrCreateChannel', { query, e });
                throw e;
            });
            log.debug('[end] apiClient.findOrCreateChannel', { query });
            const channel = (0, _1.channelFactory)(this.appId, this._eventObserverFactory(this.appId, channelDto), this.apiClient, channelDto, this.config);
            return channel;
        });
    }
    deleteChannel(channelId) {
        return this.apiClient.deleteChannel(this.appId, channelId);
    }
    close() {
        if (this.closed) {
            return;
        }
        this.closed = true;
        log.debug('closed', { appid: this.appId });
        this.apiClient.close();
    }
}
exports.RtcApiClient = RtcApiClient;
//# sourceMappingURL=client.js.map