"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransportRepository = void 0;
const common_1 = require("@skyway-sdk/common");
const core_1 = require("@skyway-sdk/core");
const mediasoup_client_1 = require("mediasoup-client");
const errors_1 = require("../../errors");
const transport_1 = require("./transport");
const log = new common_1.Logger('packages/sfu-bot/src/connection/transport/transportRepository.ts');
class TransportRepository {
    constructor(_context, _api) {
        this._context = _context;
        this._api = _api;
        this.onTransportCreated = new common_1.Event();
        /**@private */
        this._transports = {};
        this.getTransport = (personId, id) => this._transports[personId + id];
        const { browserName, browserVersion } = (0, core_1.getRuntimeInfo)();
        log.debug('runtime info', { browserName, browserVersion });
        // wkwebview対応
        if (browserName === 'Safari' && browserVersion == undefined) {
            this._device = new mediasoup_client_1.Device({ handlerName: 'Safari12' });
        }
        else {
            this._device = new mediasoup_client_1.Device();
        }
    }
    get rtpCapabilities() {
        if (!this._device.loaded) {
            return undefined;
        }
        return this._device.rtpCapabilities;
    }
    loadDevice(rtpCapabilities) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._device.loaded) {
                yield this._device
                    .load({
                    routerRtpCapabilities: rtpCapabilities,
                })
                    .catch((err) => {
                    throw (0, core_1.createError)({
                        operationName: 'TransportRepository.loadDevice',
                        context: this._context,
                        info: Object.assign(Object.assign({}, errors_1.errors.internal), { detail: 'loadDevice failed' }),
                        path: log.prefix,
                        payload: { rtpCapabilities },
                        error: err,
                    });
                });
                log.debug('device loaded', {
                    routerRtpCapabilities: rtpCapabilities,
                    rtpCapabilities: this._device.rtpCapabilities,
                });
            }
        });
    }
    /**worker内にmemberIdに紐つくTransportが無ければ新しいTransportが作られる */
    createTransport(personId, bot, transportOptions, direction, iceManager, analyticsSession) {
        const createTransport = direction === 'send'
            ? (o) => this._device.createSendTransport(o)
            : (o) => this._device.createRecvTransport(o);
        const msTransport = createTransport(Object.assign(Object.assign({}, transportOptions), { iceServers: iceManager.iceServers, iceTransportPolicy: this._context.config.rtcConfig.turnPolicy === 'turnOnly'
                ? 'relay'
                : undefined, additionalSettings: this._context.config.rtcConfig }));
        const transport = new transport_1.SfuTransport(msTransport, bot, iceManager, this._api, this._context, analyticsSession);
        this._transports[personId + msTransport.id] = transport;
        this.onTransportCreated.emit(msTransport.id);
        return transport;
    }
    deleteTransports(personId) {
        Object.entries(Object.assign({}, this._transports)).forEach(([id, transport]) => {
            if (id.includes(personId)) {
                transport.close();
                delete this._transports[id];
            }
        });
    }
}
exports.TransportRepository = TransportRepository;
//# sourceMappingURL=transportRepository.js.map