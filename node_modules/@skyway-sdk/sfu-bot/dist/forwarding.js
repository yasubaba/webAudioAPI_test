"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Forwarding = void 0;
const common_1 = require("@skyway-sdk/common");
const core_1 = require("@skyway-sdk/core");
const errors_1 = require("./errors");
const log = new common_1.Logger('packages/sfu-bot/src/connection/sender.ts');
class Forwarding {
    /**@internal */
    constructor(props) {
        this.props = props;
        this.state = 'started';
        this.configure = this.props.configure;
        this.originPublication = this.props.originPublication;
        this.relayingPublication = this.props.relayingPublication;
        this._identifierKey = this.props.identifierKey;
        this._api = this.props.api;
        this._context = this.props.context;
        /** @description [japanese] forwardingが終了された時に発火するイベント */
        this.onStopped = new common_1.Event();
        this.relayingPublication.onSubscribed.add((e) => __awaiter(this, void 0, void 0, function* () {
            yield this.confirmSubscription(e.subscription).catch((e) => e);
        }));
        this.relayingPublication.subscriptions.forEach((subscription) => __awaiter(this, void 0, void 0, function* () {
            yield this.confirmSubscription(subscription).catch((e) => e);
        }));
    }
    get id() {
        return this.relayingPublication.id;
    }
    /**@private */
    _stop() {
        this.state = 'stopped';
        this.onStopped.emit();
    }
    /**@internal */
    toJSON() {
        return {
            id: this.id,
            configure: this.configure,
            originPublication: this.originPublication,
            relayingPublication: this.relayingPublication,
        };
    }
    confirmSubscription(subscription) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug('[start] Forwarding confirmSubscription');
            const { message } = yield this._api
                .confirmSubscription({
                forwardingId: this.id,
                subscriptionId: subscription.id,
                identifierKey: this._identifierKey,
            })
                .catch((error) => {
                log.error('Forwarding confirmSubscription failed:', error);
                throw (0, core_1.createError)({
                    operationName: 'Forwarding.confirmSubscription',
                    context: this._context,
                    info: errors_1.errors.confirmSubscriptionFailed,
                    path: log.prefix,
                    payload: error,
                });
            });
            log.debug('[end] Forwarding confirmSubscription', { message });
        });
    }
}
exports.Forwarding = Forwarding;
//# sourceMappingURL=forwarding.js.map