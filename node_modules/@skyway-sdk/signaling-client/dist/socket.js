"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = void 0;
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const event_1 = require("./utils/event");
const version_1 = require("./version");
const ServerEventType = ['open', 'sendRequestSignalingMessage', 'sendResponseSignalingMessage', 'acknowledge'];
const getReconnectWaitTime = (reconnectCount) => {
    return (Math.pow(2, reconnectCount) + Math.random()) * 1000;
};
class Socket {
    constructor({ channelId, channelName, memberId, memberName, sessionEndpoint, token, logger }) {
        this._isOpen = false;
        this._isDestroyed = false;
        this._reconnectCount = 0;
        this.connectionState = 'closed';
        this.onConnectionStateChanged = new event_1.Event();
        this.onOpened = new event_1.Event();
        this.onEventReceived = new event_1.Event();
        this.onConnectionFailed = new event_1.Event();
        this._sessionEndpoint = sessionEndpoint;
        this._channelId = channelId;
        this._channelName = channelName;
        this._memberId = memberId;
        this._memberName = memberName;
        this._token = token;
        this._logger = logger;
        this._connect();
    }
    _setConnectionState(state) {
        this._logger.debug(`connectionState changed : ${state}`);
        this.connectionState = state;
        this.onConnectionStateChanged.emit(state);
    }
    _connect() {
        let ws;
        try {
            // We use the SubProtocol header to send the token.
            // This is because the browser's WebSocket class does not allow the header to be changed freely.
            const subProtocol = `SkyWayAuthToken!${this._token}`;
            const wsProperties = {
                channelId: this._channelId,
                channelName: this._channelName,
                memberId: this._memberId,
                memberName: this._memberName,
                platform: 'javascript',
                version: version_1.PACKAGE_VERSION,
            };
            const queryString = Object.entries(wsProperties)
                .filter(([_, v]) => v !== undefined)
                .map((pair) => pair.join('='))
                .join('&');
            const wsURL = `${this._sessionEndpoint}?${queryString}`;
            ws = new isomorphic_ws_1.default(wsURL, subProtocol);
            this._logger.debug(`Connecting to signaling-server: ${this._sessionEndpoint}`);
            ws.onerror = (event) => {
                this._logger.error('WebSocket error occurred', event.error);
                ws.close(4202);
            };
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error();
            this._logger.error('Failed to create WebSocket instance', error);
            this.reconnect();
            return;
        }
        ws.onopen = () => {
            this._logger.debug('Connected to signaling-server');
        };
        ws.onclose = (event) => {
            const logMessage = 'Close event fired: ' + JSON.stringify({ code: event.code, reason: event.reason, type: event.type });
            // 1000, 4000~4099: normal case (should not reconnect)
            // 4100~4199: non-normal case (should not reconnect)
            // 4200~4299: non-normal case (should reconnect)
            // others: unexpected case (should reconnect)
            if (4100 <= event.code && event.code <= 4199) {
                this._logger.error(logMessage, new Error());
            }
            else {
                this._logger.debug(logMessage);
            }
            if (event.code !== 1000 && !(4000 <= event.code && event.code <= 4199)) {
                this.reconnect();
                return;
            }
            // Return not to destroy _ws successfully reconnected
            if (event.code === 4000) {
                return;
            }
            this._logger.debug('Closed the connection to signaling-server');
            this.onConnectionFailed.emit();
            this.destroy();
        };
        ws.onmessage = (event) => {
            this._messageHandler(event.data);
        };
        this._ws = ws;
    }
    updateAuthToken(token) {
        this._token = token;
    }
    reconnect() {
        if (this._ws !== undefined) {
            this._ws.close(4000);
        }
        this._ws = undefined;
        this._isOpen = false;
        if (this._reconnectCount >= 8) {
            this.onConnectionFailed.emit();
            this.destroy();
            this._logger.error('Failed to reconnect for eight times', new Error());
        }
        else {
            this._setConnectionState('reconnecting');
            const waitTime = getReconnectWaitTime(this._reconnectCount);
            this._reconnectTimer = setTimeout(() => {
                this._connect();
                this._reconnectCount++;
                this._logger.debug(`Try to reconnect: count = ${this._reconnectCount}`);
            }, waitTime);
        }
    }
    destroy() {
        this._isDestroyed = true;
        this._setConnectionState('closed');
        this.onConnectionStateChanged.removeAllListeners();
        this.onOpened.removeAllListeners();
        this.onEventReceived.removeAllListeners();
        this.onConnectionFailed.removeAllListeners();
        if (this._reconnectTimer) {
            clearTimeout(this._reconnectTimer);
        }
        if (this._ws !== undefined) {
            this._ws.close(1000);
        }
    }
    send(clientEvent) {
        return new Promise((resolve, reject) => {
            const retrySend = () => {
                this.onOpened.addOneTimeListener(() => {
                    this.send(clientEvent)
                        .then(() => {
                        resolve();
                    })
                        .catch((err) => {
                        reject(err);
                    });
                });
                this.onConnectionFailed.addOneTimeListener(() => {
                    reject(new Error('Connection failed'));
                });
            };
            if (this._isDestroyed) {
                reject(new Error('The socket is already destroyed'));
                return;
            }
            if (this._ws === undefined || !this._isOpen) {
                // Call send method again after connected
                this._logger.debug('Retry send the client event when connected because WebSocket is undefined or isOpen = false');
                retrySend();
                return;
            }
            this._logger.debug(`Send the event: ${clientEvent.data}`);
            this._ws.send(clientEvent.data, (err) => {
                if (err) {
                    // If state is invalid, call send method again after reconnected
                    if (this._ws === undefined || !this._isOpen || this._ws.readyState !== isomorphic_ws_1.default.OPEN) {
                        this._logger.debug('Retry send the client event when connected because WebSocket.send failed');
                        retrySend();
                        return;
                    }
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    _messageHandler(data) {
        if (typeof data !== 'string') {
            this._logger.error('Received invalid message: not string', new Error());
            return;
        }
        let parsedData;
        try {
            parsedData = JSON.parse(data);
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error();
            this._logger.error('Received invalid message: parse error', error);
            return;
        }
        if (!isServerEvent(parsedData)) {
            this._logger.error(`Received invalid message: ${parsedData}`, new Error());
            return;
        }
        if (parsedData.event === 'open') {
            this._logger.debug('Received a open event');
            this._isOpen = true;
            this._setConnectionState('connected');
            if (this._reconnectCount !== 0) {
                this._reconnectCount = 0;
                this._logger.debug('Succeeded to reconnect');
            }
            this.onOpened.emit();
        }
        else {
            this._logger.debug(`Received the event: ${parsedData.event}, payload: ${JSON.stringify(parsedData.payload)}`);
            this.onEventReceived.emit(parsedData);
        }
    }
}
exports.Socket = Socket;
function isServerEvent(data) {
    if (!data || typeof data !== 'object')
        return false;
    if (typeof data.event !== 'string' || !ServerEventType.includes(data.event))
        return false;
    if (typeof data.eventId !== 'string')
        return false;
    if (data.payload && typeof data.payload !== 'object')
        return false;
    return true;
}
//# sourceMappingURL=socket.js.map