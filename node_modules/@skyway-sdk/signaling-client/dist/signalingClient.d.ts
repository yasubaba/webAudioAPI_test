import { Member } from './payloadTypes';
import { ConnectionState } from './socket';
import { Event } from './utils/event';
import { Logger } from './utils/logger';
declare type SignalingClientParams = {
    token: string;
    channelId: string;
    channelName?: string;
    memberId: string;
    memberName?: string;
};
declare type SignalingClientOptions = {
    signalingServerDomain?: string;
    secure?: boolean;
    logger?: Logger;
};
export declare class SignalingClient {
    private readonly _options;
    private readonly _logger;
    private _socket;
    readonly onConnectionStateChanged: Event<ConnectionState>;
    readonly onConnectionFailed: Event<void>;
    readonly onRequested: Event<{
        data: Record<string, unknown>;
        reply: (data: Record<string, unknown>) => Promise<void>;
        requestEventId: string;
        src: Member;
    }>;
    private readonly _token;
    private readonly _channelId;
    private readonly _channelName?;
    private readonly _memberId;
    private readonly _memberName?;
    private _connectivityCheckInterval;
    private _connectivityCheckTimers;
    private _responseCallbacks;
    private _acknowledgeCallbacks;
    constructor({ token, channelId, channelName, memberId, memberName }: SignalingClientParams, options?: SignalingClientOptions);
    get connectionState(): ConnectionState;
    connect(): Promise<void>;
    disconnect(): void;
    private _startConnectivityCheck;
    private _stopConnectivityCheck;
    request(target: Member, data: Record<string, unknown>, timeoutSec?: number): Promise<Record<string, unknown>>;
    private _response;
    updateSkyWayAuthToken(token: string, timeoutSec?: number): Promise<void>;
    private _eventReceivedHandler;
    private _acknowledgeHandler;
    private _eventMessageRequestHandler;
    private _eventMessageResponseHandler;
    private _setResponseCallback;
    private _setAcknowledgeCallback;
}
export {};
//# sourceMappingURL=signalingClient.d.ts.map