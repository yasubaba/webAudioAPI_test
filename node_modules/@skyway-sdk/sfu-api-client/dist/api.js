"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SfuRestApiClient = void 0;
const common_1 = require("@skyway-sdk/common");
const const_1 = require("./const");
const errors_1 = require("./errors");
const util_1 = require("./util");
const log = new common_1.Logger('packages/sfu-api-client/src/api.ts');
class SfuRestApiClient {
    constructor(_token, _options) {
        this._token = _token;
        this._headers = { authorization: `Bearer ${this._token}` };
        this.options = Object.assign(Object.assign({}, const_1.defaultSfuApiOptions), _options);
        this.endpoint = `http${this.options.secure ? 's' : ''}://${this.options.domain}/v${this.options.version}`;
        this.http = new common_1.HttpClient(this.endpoint);
        common_1.Logger.level = this.options.log.level;
        common_1.Logger.format = this.options.log.format;
        log.debug('SfuRestApiClient spawned', { endpoint: this.endpoint });
    }
    updateToken(token) {
        this._token = token;
    }
    _commonErrorHandler(e, operationName) {
        switch (e === null || e === void 0 ? void 0 : e.status) {
            case 401:
                return (0, util_1.createError)({
                    operationName,
                    info: errors_1.errors.invalidRequestParameter,
                    path: log.prefix,
                    payload: e,
                });
            case 403:
                return (0, util_1.createError)({
                    operationName,
                    info: errors_1.errors.insufficientPermissions,
                    path: log.prefix,
                    payload: e,
                });
            case 404:
                return (0, util_1.createError)({
                    operationName,
                    info: errors_1.errors.notFound,
                    path: log.prefix,
                    payload: e,
                });
            case 429:
                return (0, util_1.createError)({
                    operationName,
                    info: errors_1.errors.quotaExceededError,
                    path: log.prefix,
                    payload: e,
                });
            default:
                return (0, util_1.createError)({
                    operationName,
                    info: errors_1.errors.backendError,
                    path: log.prefix,
                    payload: e,
                });
        }
    }
    createBot({ appId, channelId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.http
                .post('/bots', {
                appId,
                channelId,
            }, { headers: { authorization: `Bearer ${this._token}` } })
                .catch((e) => {
                throw this._commonErrorHandler(e, 'SfuRestApiClient.createBot');
            });
            return res.id;
        });
    }
    deleteBot({ botId }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.http
                .delete(`/bots/${botId}`, {
                headers: { authorization: `Bearer ${this._token}` },
            })
                .catch((e) => {
                throw this._commonErrorHandler(e, 'SfuRestApiClient.deleteBot');
            });
        });
    }
    startForwarding({ botId, publicationId, maxSubscribers, contentType, publisherId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const backOff = new common_1.BackOff();
            const body = {
                publicationId,
                maxSubscribers,
                contentType: contentType[0].toUpperCase() + contentType.slice(1),
                publisherId,
            };
            const res = yield this.http
                .post(`/bots/${botId}/forwardings`, body, {
                headers: { authorization: `Bearer ${this._token}` },
                retry: (err) => __awaiter(this, void 0, void 0, function* () {
                    if ([400, 403, 429].includes(err.status)) {
                        return false;
                    }
                    return yield backOff.wait();
                }),
            })
                .catch((e) => {
                throw this._commonErrorHandler(e, 'SfuRestApiClient.startForwarding');
            });
            if (backOff.count > 0) {
                log.warn('success to retry startForwarding', (0, util_1.createWarnPayload)({
                    operationName: 'SfuRestApiClient.startForwarding',
                    detail: 'success to retry startForwarding',
                    botId,
                    memberId: publisherId,
                    payload: { publicationId, count: backOff.count },
                }));
            }
            return res;
        });
    }
    createProducer({ botId, forwardingId, transportId, producerOptions, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const backOff = new common_1.BackOff();
            const res = yield this.http
                .put(`/bots/${botId}/forwardings/${forwardingId}/transports/producers`, { transportId, producerOptions }, {
                headers: { authorization: `Bearer ${this._token}` },
                retry: () => __awaiter(this, void 0, void 0, function* () {
                    return yield backOff.wait();
                }),
            })
                .catch((e) => {
                throw this._commonErrorHandler(e, 'SfuRestApiClient.createProducer');
            });
            if (backOff.count > 0) {
                log.warn('success to retry createProducer', (0, util_1.createWarnPayload)({
                    operationName: 'SfuRestApiClient.createProducer',
                    detail: 'success to retry createProducer',
                    botId,
                    payload: { forwardingId, transportId, count: backOff.count },
                }));
            }
            return res;
        });
    }
    /**@throws {maxSubscriberExceededError,} */
    createConsumer({ botId, forwardingId, rtpCapabilities, subscriptionId, subscriberId, spatialLayer, originPublicationId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const backOff = new common_1.BackOff({ times: 5, interval: 100 }); // 5.5sec
            const requestPayload = {
                rtpCapabilities,
                subscriptionId,
                subscriberId,
                spatialLayer,
                originPublicationId,
            };
            const res = yield this.http
                .post(`/bots/${botId}/forwardings/${forwardingId}/transports/consumers`, requestPayload, {
                retry: (err) => __awaiter(this, void 0, void 0, function* () {
                    if ([
                        400, 403,
                        //  404,
                        429,
                    ].includes(err.status)) {
                        return false;
                    }
                    return yield backOff.wait();
                }),
                headers: { authorization: `Bearer ${this._token}` },
            })
                .catch((e) => {
                if (e.status === 429) {
                    throw (0, util_1.createError)({
                        operationName: 'SfuRestApiClient.createConsumer',
                        info: errors_1.errors.maxSubscriberExceededError,
                        path: log.prefix,
                        payload: e,
                    });
                }
                else if (e.status === 403) {
                    throw (0, util_1.createError)({
                        operationName: 'SfuRestApiClient.createConsumer',
                        info: errors_1.errors.notAllowedConsumeError,
                        path: log.prefix,
                        payload: e,
                    });
                }
                else {
                    throw this._commonErrorHandler(e, 'SfuRestApiClient.createConsumer');
                }
            });
            if (backOff.count > 0) {
                log.warn('success to retry createConsumer', (0, util_1.createWarnPayload)({
                    operationName: 'SfuRestApiClient.createConsumer',
                    detail: 'success to retry createConsumer',
                    botId,
                    payload: { forwardingId, count: backOff.count },
                }));
            }
            log.debug('response of createConsumer', res);
            return res;
        });
    }
    connect({ transportId, dtlsParameters, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const backOff = new common_1.BackOff();
            const body = { transportId, dtlsParameters };
            const res = yield this.http
                .put(`/transports/connections`, body, {
                headers: { authorization: `Bearer ${this._token}` },
                retry: () => __awaiter(this, void 0, void 0, function* () {
                    return yield backOff.wait();
                }),
            })
                .catch((e) => {
                throw this._commonErrorHandler(e, 'SfuRestApiClient.connect');
            });
            if (backOff.count > 0) {
                log.warn('success to retry connect', (0, util_1.createWarnPayload)({
                    operationName: 'SfuRestApiClient.connect',
                    detail: 'success to retry connect',
                    payload: { transportId, count: backOff.count },
                }));
            }
            return res;
        });
    }
    changeConsumerLayer({ transportId, consumerId, spatialLayer, publicationId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.http
                .put(`transports/consumers/${consumerId}/layers`, { transportId, spatialLayer, publicationId }, {
                headers: { authorization: `Bearer ${this._token}` },
            })
                .catch((e) => {
                throw this._commonErrorHandler(e, 'SfuRestApiClient.changeConsumerLayer');
            });
            return res;
        });
    }
    stopForwarding({ botId, forwardingId, }) {
        let fulfilled = false;
        const promise = this.http
            .delete(`/bots/${botId}/forwardings/${forwardingId}`, {
            headers: { authorization: `Bearer ${this._token}` },
        })
            .catch((e) => {
            throw this._commonErrorHandler(e, 'SfuRestApiClient.stopForwarding');
        })
            .then((res) => {
            fulfilled = res;
        });
        return { promise, fulfilled };
    }
    iceRestart({ transportId }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.http
                .put(`/transports/connections/ice`, { transportId }, { headers: this._headers })
                .catch((e) => {
                throw this._commonErrorHandler(e, 'SfuRestApiClient.iceRestart');
            });
            return res.iceParameters;
        });
    }
    getRtpCapabilities({ botId, forwardingId, originPublicationId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const backOff = new common_1.BackOff();
            const res = yield this.http
                .get(`/bots/${botId}/forwardings/${forwardingId}/transports/rtp-capabilities?originPublicationId=${originPublicationId}`, {
                headers: { authorization: `Bearer ${this._token}` },
                retry: () => __awaiter(this, void 0, void 0, function* () {
                    return yield backOff.wait();
                }),
            })
                .catch((e) => {
                throw this._commonErrorHandler(e, 'SfuRestApiClient.getRtpCapabilities');
            });
            if (backOff.count > 0) {
                log.warn('getCapabilities to retry connect', (0, util_1.createWarnPayload)({
                    operationName: 'SfuRestApiClient.getRtpCapabilities',
                    detail: 'getCapabilities to retry connect',
                    botId,
                    payload: { forwardingId, count: backOff.count },
                }));
            }
            return res.rtpCapabilities;
        });
    }
    confirmSubscription({ forwardingId, subscriptionId, identifierKey, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestPayload = {
                forwardingId,
                subscriptionId,
                identifierKey,
            };
            const res = yield this.http
                .post('/confirm-subscription', requestPayload, {
                headers: { authorization: `Bearer ${this._token}` },
            })
                .catch((e) => {
                throw this._commonErrorHandler(e, 'SfuRestApiClient.confirmSubscription');
            });
            log.debug('response of confirmSubscription', res);
            return res;
        });
    }
}
exports.SfuRestApiClient = SfuRestApiClient;
//# sourceMappingURL=api.js.map